% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gather_samples.R, R/spread_samples.R
\name{gather_samples}
\alias{gather_samples}
\alias{spread_samples}
\alias{extract_samples}
\alias{tidy_samples}
\title{Extract samples of parameters in a Bayesian model fit into a tidy data format}
\usage{
gather_samples(model, ..., regex = FALSE, sep = "[, ]")

spread_samples(model, ..., regex = FALSE, sep = "[, ]")
}
\arguments{
\item{model}{A supported Bayesian model fit / MCMC object. Tidybayes supports a variety of model objects;
for a full list of supported models, see \link{tidybayes-models}.}

\item{...}{Expressions in the form of
\code{variable_name[index_1, index_2, ...] | wide_index}. See `Details`.}

\item{regex}{If \code{TRUE}, parameter names are treated as regular expressions and all column matching the
regular expression and number of indices are included in the output. Default \code{FALSE}.}

\item{sep}{Separator used to separate indices in parameter names, as a regular expression.}
}
\value{
A data frame.
}
\description{
Extract samples from a Bayesian/MCMC sampler for a variable with the given named
indices into one of two types of long-format data frames.
}
\details{
Imagine a JAGS or Stan fit named \code{fit}. The model may contain a parameter named
\code{b[i,v]} (in the JAGS or Stan language) with \code{i} in \code{1:100} and \code{v} in \code{1:3}.
However, samples returned from JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like \code{"b[1,1]"}, \code{"b[2,1]"}, etc.

\code{spread_samples} and \code{gather_samples} provide a straightforward
syntax to translate these columns back into properly-indexed variables in two different
tidy data frame formats, optionally recovering index types (e.g. factor levels) as it does so.

\code{spread_samples} and \code{gather_samples} return data frames already grouped by
all indices used on the variables you specify.

The difference between \code{spread_samples} is that names of parameters in the model will
be spread across the data frame as column names, whereas \code{gather_samples} will
gather terms into a single column named \code{"term"} and place estimates of terms into a
column names \code{"estimate"}. The \code{"term"} and \code{"estimate"} naming scheme
is used in order to be consistent with output from the \code{\link[broom]{tidy}} function
in the broom package, to make it easier to use tidybayes with broom for model comparison.

For example, \code{spread_samples(fit, a[i], b[i,v])} might return a grouped
data frame (grouped by \code{i} and \code{v}), with:
\itemize{
   \item column \code{".chain"}: the chain number
   \item column \code{".iteration"}: the interation number
   \item column \code{"i"}: value in \code{1:5}
   \item column \code{"v"}: value in \code{1:10}
   \item column \code{"a"}: value of \code{"a[i]"} for iteration number
     \code{".iteration"} on chain number \code{".chain"}
   \item column \code{"b"}: value of \code{"b[i,v]"} for iteration number
     \code{".iteration"} on chain number \code{".chain"}
 }

\code{gather_samples(fit, a[i], b[i,v])} on the same fit would return a grouped
data frame (grouped by \code{i} and \code{v}), with:
\itemize{
   \item column \code{".chain"}: the chain number
   \item column \code{".iteration"}: the interation number
   \item column \code{"i"}: value in \code{1:5}
   \item column \code{"v"}: value in \code{1:10}, or \code{NA}
     if \code{"term"} is \code{"a"}.
   \item column \code{"term"}: value in \code{c("a", "b")}.
   \item column \code{"estimate"}: value of \code{"a[i]"} (when \code{"term"} is \code{"a"})
     or \code{"b[i,v]"} (when \code{"term"} is \code{"b"}) for iteration number
     \code{".iteration"} on chain number \code{".chain"}
 }

\code{spread_samples} and \code{gather_samples} can use type information
applied to the \code{fit} object by \code{\link{recover_types}} to convert columns
back into their original types. This is particularly helpful if some of the indices in
your model were originally factors. For example, if the \code{v} index
in the original data frame \code{data} was a factor with levels \code{c("a","b","c")},
then we could use \code{recover_types} before \code{spread_samples}:

\preformatted{fit \%>\%
 recover_types(data) %\>\%
 spread_samples(fit, b[i,v])
}

Which would return the same data frame as above, except the \code{"v"} column
would be a value in \code{c("a","b","c")} instead of \code{1:3}.

For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately.
For example, if we have a variable d[i] with the same i subscript
as b[i,v], and a variable x with no subscripts, we could do this:

\preformatted{spread_samples(fit, x, d[i], b[i,v])}

Which is roughly equivalent to this:

\preformatted{spread_samples(fit, x) \%>\%
 inner_join(spread_samples(fit, d[i])) \%>\%
 inner_join(spread_samples(fit, b[i,v])) \%>\%
 group_by(i,v)
}

Similarly, this:

\preformatted{gather_samples(fit, x, d[i], b[i,v])}

Is roughly equivalent to this:

\preformatted{bind_rows(
 gather_samples(fit, x),
 gather_samples(fit, d[i]),
 gather_samples(fit, b[i,v])
)}

The \code{c} and \code{cbind} functions can be used to combine multiple variable names that have
the same indices. For example, if we have several variables with the same
subscripts \code{i} and \code{v}, we could do either of these:

\preformatted{spread_samples(fit, c(w, x, y, z)[i,v])}
\preformatted{spread_samples(fit, cbind(w, x, y, z)[i,v])}  # equivalent

Each of which is roughly equivalent to this:

\preformatted{spread_samples(fit, w[i,v], x[i,v], y[i,v], z[i,v])}

Besides being more compact, the \code{c()}-style syntax is currently also
faster (though that may change).

Indices can be omitted from the resulting data frame by leaving their names
blank; e.g. \code{spread_samples(fit, b[,v])} will omit the first index of
\code{b} from the output. This is useful if an index is known to contain all
the same value in a given model.

The shorthand \code{..} can be used to specify one column that should be put
into a wide format and whose names will be the base variable name, plus a dot
("."), plus the value of the index at \code{..}. For example:

\code{spread_samples(fit, b[i,..])} would return a grouped data frame
(grouped by \code{i}), with:
\itemize{
 \item column \code{".chain"}: the chain number
 \item column \code{".iteration"}: the interation number
 \item column \code{"i"}: value in \code{1:20}
 \item column \code{"b.1"}: value of \code{"b[i,1]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
 \item column \code{"b.2"}: value of \code{"b[i,2]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
 \item column \code{"b.3"}: value of \code{"b[i,3]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
}

An optional clause in the form \code{| wide_index} can also be used to put
the data frame into a wide format based on \code{wide_index}. For example, this:

\preformatted{spread_samples(fit, b[i,v] | v)}

is roughly equivalent to this:

\preformatted{spread_samples(fit, b[i,v]) \%>\% spread(v,b)}

The main difference between using the \code{|} syntax instead of the
\code{..} syntax is that the \code{|} syntax respects prototypes applied to
indices with \code{\link{recover_types}}, and thus can be used to get
columns with nicer names. For example:

\code{fit \%>\% recover_types(data) \%>\% spread_samples(b[i,v] | v)} would return a grouped data frame
(grouped by \code{i}), with:
\itemize{
 \item column \code{".chain"}: the chain number
 \item column \code{".iteration"}: the interation number
 \item column \code{"i"}: value in \code{1:20}
 \item column \code{"a"}: value of \code{"b[i,1]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
 \item column \code{"b"}: value of \code{"b[i,2]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
 \item column \code{"c"}: value of \code{"b[i,3]"} for iteration number
   \code{".iteration"} on chain number \code{".chain"}
}

Finally, parameter names can be regular expressions by setting \code{regex = TRUE}; e.g.:

\code{spread_samples(fit, `b_.*`[i], regex = TRUE)}

Would return a tidy data frame with parameters starting with `b_` and having one index.
}
\examples{

library(magrittr)
library(ggplot2)

data(RankCorr, package = "tidybayes")

RankCorr \%>\%
  spread_samples(b[i, j])

RankCorr \%>\%
  spread_samples(b[i, j], tau[i], u_tau[i])


RankCorr \%>\%
  gather_samples(b[i, j], tau[i], u_tau[i])

RankCorr \%>\%
  gather_samples(tau[i], typical_r) \%>\%
  median_qi()

}
\seealso{
\code{\link{recover_types}}, \code{\link{compose_data}}.
}
\author{
Matthew Kay
}
\keyword{manip}
