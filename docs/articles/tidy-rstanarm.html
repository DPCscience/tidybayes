<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Extracting tidy samples from rstanarm • tidybayes</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">tidybayes</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/tidybayes.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/tidy-rstanarm.html">Extracting tidy samples from rstanarm</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mjskay/tidybayes">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Extracting tidy samples from rstanarm</h1>
                        <h4 class="author">Matthew Kay</h4>
            
            <h4 class="date">2017-08-24</h4>
          </div>

    
    
<div class="contents">
<style type="text/css">
.kable-table table {
  margin-left: 0;
}
img {
  border: none;
}
</style>
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>This vignette describes how to use the <code>tidybayes</code> package to extract tidy samples from <code>rstanarm</code>. For a more general introduction to <code>tidybayes</code> and its use on more general-purpose sampling languages (like Stan and JAGS), see <a href="tidybayes.html">vignette(“tidybayes”)</a>.</p>
<p>The default output data formats of popular samplers like JAGS and Stan often don’t quite conform to the ideal of <a href="http://dx.doi.org/10.18637/jss.v059.i10">tidy data</a>. Output formats will often be in matrix form (requiring conversion for use with libraries like ggplot). <code>tidybayes</code> automates munging the samples into tidy formats.</p>
</div>
<div id="setup" class="section level2">
<h2 class="hasAnchor">
<a href="#setup" class="anchor"></a>Setup</h2>
<p>The following libraries are required to run this vignette:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(tidybayes)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(ggstance)
<span class="kw">library</span>(rstan)
<span class="kw">library</span>(rstanarm)</code></pre></div>
<p>These options help Stan run faster:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rstan_options</span>(<span class="dt">auto_write =</span> <span class="ot">TRUE</span>)
<span class="kw">options</span>(<span class="dt">mc.cores =</span> parallel::<span class="kw">detectCores</span>())</code></pre></div>
</div>
<div id="example-dataset" class="section level2">
<h2 class="hasAnchor">
<a href="#example-dataset" class="anchor"></a>Example dataset</h2>
<p>To demonstrate <code>tidybayes</code>, we will use a simple dataset with 10 observations from 5 conditions each:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">5</span>)
n =<span class="st"> </span><span class="dv">10</span>
n_condition =<span class="st"> </span><span class="dv">5</span>
ABC =
<span class="st">  </span><span class="kw">data_frame</span>(
    <span class="dt">condition =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>,<span class="st">"D"</span>,<span class="st">"E"</span>), n),
    <span class="dt">response =</span> <span class="kw">rnorm</span>(n *<span class="st"> </span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,-<span class="dv">1</span>), <span class="fl">0.5</span>)
  )</code></pre></div>
<p>A snapshot of the data looks like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(ABC, <span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 2
##    condition   response
##        &lt;chr&gt;      &lt;dbl&gt;
##  1         A -0.4204277
##  2         B  1.6921797
##  3         C  1.3722541
##  4         D  1.0350714
##  5         E -0.1442796
##  6         A -0.3014540
##  7         B  0.7639168
##  8         C  1.6823143
##  9         D  0.8571132
## 10         E -0.9309459</code></pre>
<p><em>(10 rows of 50)</em></p>
<p>This is a typical tidy format data frame: one observation per row. Graphically:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ABC %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> condition, <span class="dt">x =</span> response)) +
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-4-1.png" width="576"></p>
</div>
<div id="model" class="section level2">
<h2 class="hasAnchor">
<a href="#model" class="anchor"></a>Model</h2>
<p>Let’s fit a hierarchical model with shrinkage towards a global mean:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="kw">stan_lmer</span>(response ~<span class="st"> </span>(<span class="dv">1</span>|condition), <span class="dt">data =</span> ABC, 
  <span class="dt">prior =</span> <span class="kw">normal</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">autoscale =</span> <span class="ot">FALSE</span>),
  <span class="dt">prior_aux =</span> <span class="kw">student_t</span>(<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">autoscale =</span> <span class="ot">FALSE</span>),
  <span class="dt">adapt_delta =</span> .<span class="dv">99</span>)</code></pre></div>
<pre><code>## trying deprecated constructor; please alert package maintainer</code></pre>
<p>The results look like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(m)</code></pre></div>
<pre><code>## 
## Model Info:
## 
##  function:  stan_lmer
##  family:    gaussian [identity]
##  formula:   response ~ (1 | condition)
##  algorithm: sampling
##  priors:    see help('prior_summary')
##  sample:    4000 (posterior sample size)
##  num obs:   50
##  groups:    condition (5)
## 
## Estimates:
##                                            mean   sd    2.5%   25%   50%
## (Intercept)                                0.6    0.5  -0.4    0.3   0.6
## b[(Intercept) condition:A]                -0.4    0.5  -1.5   -0.7  -0.4
## b[(Intercept) condition:B]                 0.4    0.5  -0.8    0.0   0.4
## b[(Intercept) condition:C]                 1.2    0.5   0.1    0.9   1.2
## b[(Intercept) condition:D]                 0.4    0.5  -0.7    0.1   0.4
## b[(Intercept) condition:E]                -1.5    0.5  -2.6   -1.8  -1.5
## sigma                                      0.6    0.1   0.5    0.5   0.6
## Sigma[condition:(Intercept),(Intercept)]   1.3    1.1   0.3    0.7   1.0
## mean_PPD                                   0.6    0.1   0.4    0.6   0.6
## log-posterior                            -56.9    2.4 -62.9  -58.3 -56.5
##                                            75%   97.5%
## (Intercept)                                0.9   1.7  
## b[(Intercept) condition:A]                -0.1   0.6  
## b[(Intercept) condition:B]                 0.7   1.4  
## b[(Intercept) condition:C]                 1.5   2.3  
## b[(Intercept) condition:D]                 0.7   1.4  
## b[(Intercept) condition:E]                -1.2  -0.5  
## sigma                                      0.6   0.7  
## Sigma[condition:(Intercept),(Intercept)]   1.5   3.8  
## mean_PPD                                   0.7   0.9  
## log-posterior                            -55.2 -53.4  
## 
## Diagnostics:
##                                          mcse Rhat n_eff
## (Intercept)                              0.0  1.0   968 
## b[(Intercept) condition:A]               0.0  1.0  1036 
## b[(Intercept) condition:B]               0.0  1.0  1003 
## b[(Intercept) condition:C]               0.0  1.0   978 
## b[(Intercept) condition:D]               0.0  1.0  1027 
## b[(Intercept) condition:E]               0.0  1.0  1011 
## sigma                                    0.0  1.0  2556 
## Sigma[condition:(Intercept),(Intercept)] 0.0  1.0  1374 
## mean_PPD                                 0.0  1.0  3721 
## log-posterior                            0.1  1.0  1069 
## 
## For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).</code></pre>
</div>
<div id="gathering-samples-from-a-fit-in-tidy-format-using-spread_samples" class="section level2">
<h2 class="hasAnchor">
<a href="#gathering-samples-from-a-fit-in-tidy-format-using-spread_samples" class="anchor"></a>Gathering samples from a fit in tidy-format using <code>spread_samples</code>
</h2>
<p>Now that we have our results, the fun begins: getting the samples out in a tidy format! For example, given these parameters:</p>
<ul>
<li><code>b[(Intercept) condition:A]</code></li>
<li><code>b[(Intercept) condition:B]</code></li>
<li><code>b[(Intercept) condition:C]</code></li>
<li><code>b[(Intercept) condition:D]</code></li>
<li><code>b[(Intercept) condition:E]</code></li>
</ul>
<p>We might want a data frame where each row is a sample from either <code>b[(Intercept) condition:A]</code>, <code>b[(Intercept) condition:B]</code>, <code>...:C]</code>, <code>...:D]</code>, or <code>...:E]</code>, and where we have columns indexing which iteration of the sampler the sample came from and which condition it is for. That would allow us to easily compute quantities grouped by condition, or generate plots by condition using ggplot, or even merge samples with the original data to plot data and estimates.</p>
<p>The workhorse of <code>tidybayes</code> is the <code>spread_samples</code> function, which does this extraction for us. It includes a simple specification format that we can use to extract parameters and their indices into tidy-format data frames.</p>
<div id="gathering-parameter-indices-into-a-separate-column-in-a-tidy-format-data-frame" class="section level3">
<h3 class="hasAnchor">
<a href="#gathering-parameter-indices-into-a-separate-column-in-a-tidy-format-data-frame" class="anchor"></a>Gathering parameter indices into a separate column in a tidy format data frame</h3>
<p>Given a parameter like this:</p>
<p><code>b[(Intercept) condition:D]</code></p>
<p>We can provide <code>spread_samples</code> with a column specification like this:</p>
<p><code>b[term,group,condition]</code></p>
<p>Where <code>term</code> corresponds to <code>(Intercept)</code>, <code>group</code> to <code>condition</code>, and <code>condition</code> to <code>D</code>. There is nothing too magical about what <code>spread_samples</code> does with this specification: under the hood, it splits the parameter indices by spaces, <code>:</code>, and <code>,</code>, and lets you assign columns to the resulting indices in order. So <code>b[(Intercept) condition:D]</code> has indices <code>(Intercept)</code>, <code>condition</code>, and <code>D</code>, and gather samples lets us extract these indices as columns and get a tidy data frame of samples of <code>b</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[term,group,condition]) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 6
## # Groups:   term, group, condition [5]
##    .chain .iteration        term     group condition          b
##     &lt;int&gt;      &lt;int&gt;       &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;
##  1      1          1 (Intercept) condition         A -0.4153273
##  2      1          1 (Intercept) condition         B  0.2221692
##  3      1          1 (Intercept) condition         C  0.9201018
##  4      1          1 (Intercept) condition         D  0.2773821
##  5      1          1 (Intercept) condition         E -1.8359644
##  6      1          2 (Intercept) condition         A -0.7725661
##  7      1          2 (Intercept) condition         B  0.2706790
##  8      1          2 (Intercept) condition         C  1.1032067
##  9      1          2 (Intercept) condition         D  0.0731117
## 10      1          2 (Intercept) condition         E -1.6890449</code></pre>
<p><em>(10 rows of 20000)</em></p>
<p>We can choose whatever names we want for the index columns; e.g.:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[t,g,c]) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 6
## # Groups:   t, g, c [5]
##    .chain .iteration           t         g     c          b
##     &lt;int&gt;      &lt;int&gt;       &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;
##  1      1          1 (Intercept) condition     A -0.4153273
##  2      1          1 (Intercept) condition     B  0.2221692
##  3      1          1 (Intercept) condition     C  0.9201018
##  4      1          1 (Intercept) condition     D  0.2773821
##  5      1          1 (Intercept) condition     E -1.8359644
##  6      1          2 (Intercept) condition     A -0.7725661
##  7      1          2 (Intercept) condition     B  0.2706790
##  8      1          2 (Intercept) condition     C  1.1032067
##  9      1          2 (Intercept) condition     D  0.0731117
## 10      1          2 (Intercept) condition     E -1.6890449</code></pre>
<p><em>(10 rows of 20000)</em></p>
<p>But the more descriptive and less cryptic names from the previous example are probably preferable.</p>
<p>In this particular model, there is only one term (<code>(Intercept)</code>) and one group (<code>condition</code>), thus we could omit those two indices altogether to just get each <code>condition</code> and the value of <code>b</code> for that condition:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 4
## # Groups:   condition [5]
##    .chain .iteration condition          b
##     &lt;int&gt;      &lt;int&gt;     &lt;chr&gt;      &lt;dbl&gt;
##  1      1          1         A -0.4153273
##  2      1          1         B  0.2221692
##  3      1          1         C  0.9201018
##  4      1          1         D  0.2773821
##  5      1          1         E -1.8359644
##  6      1          2         A -0.7725661
##  7      1          2         B  0.2706790
##  8      1          2         C  1.1032067
##  9      1          2         D  0.0731117
## 10      1          2         E -1.6890449</code></pre>
<p><em>(10 rows of 20000)</em></p>
<p><strong>Note:</strong> If you have used <code>spread_samples</code> with raw samples from Stan or JAGS, you may be used to using <code>recover_types</code> before <code>spread_samples</code> to get index column values back (e.g. if the index was a factor). This is not necessary when using <code>spread_samples</code> on <code>rstanarm</code> models, because those models already contain that information in their parameter names. For more on <code>recover_types</code>, see <code><a href="tidybayes.html">vignette(“tidybayes”)</a></code>.</p>
</div>
</div>
<div id="point-estimates-and-intervals" class="section level2">
<h2 class="hasAnchor">
<a href="#point-estimates-and-intervals" class="anchor"></a>Point estimates and intervals</h2>
<div id="with-simple-parameters" class="section level3">
<h3 class="hasAnchor">
<a href="#with-simple-parameters" class="anchor"></a>With simple parameters</h3>
<p><code>tidybayes</code> provides a family of functions for generating point estimates and intervals from samples in a tidy format. These functions follow the naming scheme <code>[mean|median|mode]_[qi|hdi]</code>, for example, <code>mean_qi</code>, <code>median_qi</code>, <code>mode_hdi</code>, and so on. The first name (before the <code>_</code>) indicates the type of point estimate, and the second name indicates the type of interval. <code>qi</code> yields a quantile interval (a.k.a. equi-tailed interval, central interval, or percentile interval) and <code>hdi</code> yields a highest (posterior) density interval. Custom estimates or intervals can also be applied using the <code>point_interval</code> function.</p>
<p>For example, we might gather the samples corresponding to the overall mean and standard deviation of observations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, sigma) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 4
##    .chain .iteration `(Intercept)`     sigma
##     &lt;int&gt;      &lt;int&gt;         &lt;dbl&gt;     &lt;dbl&gt;
##  1      1          1     0.8699070 0.5333002
##  2      1          2     0.8832496 0.5056943
##  3      1          3     0.6715576 0.4930277
##  4      1          4     1.0636952 0.6305244
##  5      1          5     0.6542920 0.6138746
##  6      1          6     0.3660638 0.5466326
##  7      1          7     1.2801615 0.5720004
##  8      1          8     0.6968664 0.6624411
##  9      1          9     0.9964885 0.5224797
## 10      1         10     0.9763288 0.5209886</code></pre>
<p><em>(10 rows of 4000)</em></p>
<p>Like with <code>b[term,group,condition]</code>, this gives us a tidy data frame. If we want the mean and 95% quantile interval of the parameters, we can apply <code>mean_qi</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, sigma) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, sigma)</code></pre></div>
<pre><code>## # A tibble: 1 x 7
##   `(Intercept)` `(Intercept).low` `(Intercept).high`     sigma sigma.low
##           &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     0.6433902        -0.3851976           1.688643 0.5665717 0.4611307
## # ... with 2 more variables: sigma.high &lt;dbl&gt;, .prob &lt;dbl&gt;</code></pre>
<p>We can specify the columns we want to get means and intervals from, as above, or if we omit the list of columns, <code>mean_qi</code> will use every column that is not a grouping column or a special column (one that starts with <code>.</code>, like <code>.chain</code> or <code>.iteration</code>). Thus in the above example, <code>(Intercept)</code> and <code>sigma</code> are redundant arguments to <code>mean_qi</code> because they are also the only columns we gathered from the model. So we can simplify this to:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, sigma) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>()</code></pre></div>
<pre><code>## # A tibble: 1 x 7
##   `(Intercept)` `(Intercept).low` `(Intercept).high`     sigma sigma.low
##           &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     0.6433902        -0.3851976           1.688643 0.5665717 0.4611307
## # ... with 2 more variables: sigma.high &lt;dbl&gt;, .prob &lt;dbl&gt;</code></pre>
<p>If you would rather have a long-format list of intervals, use <code>gather_samples</code> instead:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">gather_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, sigma) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>()</code></pre></div>
<pre><code>## # A tibble: 2 x 5
## # Groups:   term [2]
##          term  estimate   conf.low conf.high .prob
##         &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;
## 1 (Intercept) 0.6433902 -0.3851976 1.6886433  0.95
## 2       sigma 0.5665717  0.4611307 0.6967005  0.95</code></pre>
<p>The <code>conf.low</code> and <code>conf.high</code> naming scheme is used when <code>mean_qi</code> summarizes a single column in order to be consistent with the output of <code><a href="http://www.rdocumentation.org/packages/broom/topics/tidy">broom::tidy</a></code>. This makes it easier to compare output from <code>tidybayes</code> to other models supported by <code>broom</code>.</p>
<p>For more on <code>gather_samples</code>, see <code><a href="tidybayes.html">vignette(“tidybayes”)</a></code>.</p>
</div>
<div id="with-indexed-parameters" class="section level3">
<h3 class="hasAnchor">
<a href="#with-indexed-parameters" class="anchor"></a>With indexed parameters</h3>
<p>When we have a parameter with one or more indices, such as <code>b</code>, we can apply <code>mean_qi</code> (or other functions in the <code>point_estimate</code> family) as we did before:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>()</code></pre></div>
<pre><code>## # A tibble: 5 x 5
## # Groups:   condition [5]
##   condition          b   conf.low  conf.high .prob
##       &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1         A -0.4434288 -1.5048407  0.6114279  0.95
## 2         B  0.3578635 -0.7800456  1.4029255  0.95
## 3         C  1.1863379  0.1207575  2.2708772  0.95
## 4         D  0.3700134 -0.6933094  1.4065167  0.95
## 5         E -1.5211353 -2.6445936 -0.4682927  0.95</code></pre>
<p>How did <code>mean_qi</code> know what to aggregate? Data frames returned by <code>spread_samples</code> are automatically grouped by all index variables you pass to it; in this case, that means <code>spread_samples</code> groups its results by <code>condition</code>. <code>mean_qi</code> respects those groups, and calculates the estimates and intervals within all groups. Then, because no columns were passed to <code>mean_qi</code>, it acts on the only non-special (<code>.</code>-prefixed) and non-group column, <code>b</code>. So the above shortened syntax is equivalent to this more verbose call:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(condition) %&gt;%<span class="st">    </span><span class="co"># this line not necessary (done by spread_samples)</span>
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(b)                 <span class="co"># b is not necessary (it is the only non-group column)</span></code></pre></div>
<pre><code>## # A tibble: 5 x 5
## # Groups:   condition [5]
##   condition          b   conf.low  conf.high .prob
##       &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1         A -0.4434288 -1.5048407  0.6114279  0.95
## 2         B  0.3578635 -0.7800456  1.4029255  0.95
## 3         C  1.1863379  0.1207575  2.2708772  0.95
## 4         D  0.3700134 -0.6933094  1.4065167  0.95
## 5         E -1.5211353 -2.6445936 -0.4682927  0.95</code></pre>
</div>
</div>
<div id="combining-variables-with-different-indices-in-a-single-tidy-format-data-frame" class="section level2">
<h2 class="hasAnchor">
<a href="#combining-variables-with-different-indices-in-a-single-tidy-format-data-frame" class="anchor"></a>Combining variables with different indices in a single tidy format data frame</h2>
<p><code>spread_samples</code> supports gathering variables that have different indices in the same data frame. It automatically matches up indices with the same name, and duplicates values as necessary to produce one row per all combination of levels of all indices. For example, we might want to calculate the mean within each condition (call this <code>condition_mean</code>). In this model, that mean is the intercept (<code>(Intercept)</code>) plus the effect for a given condition (<code>b</code>).</p>
<p>We can gather samples from <code>(Intercept)</code> and <code>b</code> together in a single data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## # A tibble: 10 x 5
## # Groups:   condition [5]
##    .chain .iteration `(Intercept)` condition          b
##     &lt;int&gt;      &lt;int&gt;         &lt;dbl&gt;     &lt;chr&gt;      &lt;dbl&gt;
##  1      1          1     0.8699070         A -0.4153273
##  2      1          1     0.8699070         B  0.2221692
##  3      1          1     0.8699070         C  0.9201018
##  4      1          1     0.8699070         D  0.2773821
##  5      1          1     0.8699070         E -1.8359644
##  6      1          2     0.8832496         A -0.7725661
##  7      1          2     0.8832496         B  0.2706790
##  8      1          2     0.8832496         C  1.1032067
##  9      1          2     0.8832496         D  0.0731117
## 10      1          2     0.8832496         E -1.6890449</code></pre>
<p><em>(10 rows of 20000)</em></p>
<p>Within each sample, <code>(Intercept)</code> is repeated as necessary to correspond to every index of <code>b</code>. Thus, the <code>mutate</code> function from dplyr can be used to find their sum, <code>condition_mean</code> (which is the estimated mean for each condition):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">condition_mean =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(condition_mean)</code></pre></div>
<pre><code>## Warning: package 'bindrcpp' was built under R version 3.4.1</code></pre>
<pre><code>## # A tibble: 5 x 5
## # Groups:   condition [5]
##   condition condition_mean   conf.low  conf.high .prob
##       &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1         A      0.1999614 -0.1545082  0.5565023  0.95
## 2         B      1.0012536  0.6477895  1.3496700  0.95
## 3         C      1.8297281  1.4837925  2.1847173  0.95
## 4         D      1.0134035  0.6567301  1.3714016  0.95
## 5         E     -0.8777451 -1.2309913 -0.5152876  0.95</code></pre>
<p><code>mean_qi</code> can also take column expressions (rather than just column names), so we can simplify the above example by moving the calculation of <code>condition_mean</code> from <code>mutate</code> into <code>mean_qi</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(<span class="dt">condition_mean =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b)</code></pre></div>
<pre><code>## # A tibble: 5 x 5
## # Groups:   condition [5]
##   condition condition_mean   conf.low  conf.high .prob
##       &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1         A      0.1999614 -0.1545082  0.5565023  0.95
## 2         B      1.0012536  0.6477895  1.3496700  0.95
## 3         C      1.8297281  1.4837925  2.1847173  0.95
## 4         D      1.0134035  0.6567301  1.3714016  0.95
## 5         E     -0.8777451 -1.2309913 -0.5152876  0.95</code></pre>
</div>
<div id="plotting-point-estimates-and-intervals" class="section level2">
<h2 class="hasAnchor">
<a href="#plotting-point-estimates-and-intervals" class="anchor"></a>Plotting point estimates and intervals</h2>
<p>Plotting means and intervals is straightforward using the “pointrange” or “pointrangeh” geoms:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(<span class="dt">condition_mean =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> condition, <span class="dt">x =</span> condition_mean, <span class="dt">xmin =</span> conf.low, <span class="dt">xmax =</span> conf.high)) +
<span class="st">  </span><span class="kw">geom_pointrangeh</span>()</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-19-1.png" width="576"></p>
</div>
<div id="interval-estimates-with-multiple-probability-levels" class="section level2">
<h2 class="hasAnchor">
<a href="#interval-estimates-with-multiple-probability-levels" class="anchor"></a>Interval estimates with multiple probability levels</h2>
<p><code>mean_qi</code> and its sister functions can also produce an arbitrary number of probability intervals by setting the <code>.prob =</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(<span class="dt">condition_mean =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b, <span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>))</code></pre></div>
<pre><code>## # A tibble: 15 x 5
## # Groups:   condition [5]
##    condition condition_mean    conf.low  conf.high .prob
##        &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
##  1         A      0.1999614 -0.15450818  0.5565023  0.95
##  2         B      1.0012536  0.64778953  1.3496700  0.95
##  3         C      1.8297281  1.48379254  2.1847173  0.95
##  4         D      1.0134035  0.65673008  1.3714016  0.95
##  5         E     -0.8777451 -1.23099129 -0.5152876  0.95
##  6         A      0.1999614 -0.02930002  0.4283730  0.80
##  7         B      1.0012536  0.77686781  1.2357558  0.80
##  8         C      1.8297281  1.60340493  2.0550345  0.80
##  9         D      1.0134035  0.79184276  1.2419299  0.80
## 10         E     -0.8777451 -1.10581219 -0.6456298  0.80
## 11         A      0.1999614  0.08393472  0.3161406  0.50
## 12         B      1.0012536  0.87857907  1.1186001  0.50
## 13         C      1.8297281  1.71254516  1.9453390  0.50
## 14         D      1.0134035  0.89586528  1.1303665  0.50
## 15         E     -0.8777451 -0.99566047 -0.7614082  0.50</code></pre>
<p>The results are in a tidy format: one row per group and probability level (<code>.prob</code>). This facilitates plotting. For example, assigning <code>-.prob</code> to the <code>size</code> aesthetic will show all intervals, making thicker lines correspond to smaller intervals:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(<span class="dt">condition_mean =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b, <span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> condition, <span class="dt">x =</span> condition_mean, <span class="dt">xmin =</span> conf.low, <span class="dt">xmax =</span> conf.high, 
    <span class="dt">size =</span> -.prob    <span class="co"># shorter interval =&gt; thicker line</span>
  )) +
<span class="st">  </span><span class="kw">geom_pointrangeh</span>(
    <span class="dt">fatten =</span> <span class="dv">2</span>         <span class="co"># smaller point estimate (otherwise it is very large)</span>
  ) +
<span class="st">  </span><span class="kw">scale_size_continuous</span>(
    <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">2.5</span>),   <span class="co"># default range is c(0, 6) --- makes very thick lines</span>
    <span class="dt">guide =</span> <span class="ot">FALSE</span>      <span class="co"># no need for a legend on size</span>
  )</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-21-1.png" width="576"></p>
</div>
<div id="making-posterior-predictions" class="section level2">
<h2 class="hasAnchor">
<a href="#making-posterior-predictions" class="anchor"></a>Making posterior predictions</h2>
<p>We can use combinations of variables with difference indices to generate predictions from the model. In this case, we can combine the group means with the residual standard deviation to generate predictive distributions from the model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition], sigma) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pred =</span> <span class="kw">rnorm</span>(<span class="kw">n</span>(), <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b, sigma)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> pred)) +
<span class="st">  </span><span class="kw">stat_density</span>() +
<span class="st">  </span><span class="kw">facet_grid</span>(condition ~<span class="st"> </span>., <span class="dt">switch =</span> <span class="st">"y"</span>)</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-22-1.png" width="576"></p>
<p>And even summarize these as predictive intervals and compare to the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition], sigma) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pred =</span> <span class="kw">rnorm</span>(<span class="kw">n</span>(), <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b, sigma)) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(pred, <span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition, <span class="dt">y =</span> pred)) +
<span class="st">  </span><span class="kw">geom_linerange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high, 
    <span class="dt">color =</span> <span class="kw">ordered</span>(-.prob)),
    <span class="dt">size =</span> <span class="dv">4</span>) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> response), <span class="dt">data =</span> ABC) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="dt">guide =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-23-1.png" width="576"></p>
<p>If this model is well-calibrated, about 95% of the data should be in the outer intervals, 80% in the next-smallest intervals, and 50% in the smallest intervals.</p>
<p>Altogether, data, posterior predictions, and estimates of the means:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">samples =<span class="st"> </span>m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition], sigma) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">mu =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b)

reps =<span class="st"> </span>samples %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pred =</span> <span class="kw">rnorm</span>(<span class="kw">n</span>(), mu, sigma)) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(pred, <span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>))

parameters =<span class="st"> </span>samples %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(mu, <span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">66</span>))

ABC %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition)) +
<span class="st">  </span><span class="kw">geom_linerange</span>(
    <span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high, 
      <span class="dt">color =</span> <span class="kw">ordered</span>(-.prob)),
    <span class="dt">size =</span> <span class="dv">4</span>, 
    <span class="dt">data =</span> reps) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(
    <span class="kw">aes</span>(<span class="dt">y =</span> mu, <span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high, 
      <span class="dt">size =</span> -.prob),
    <span class="dt">fatten =</span> <span class="fl">1.5</span>, <span class="dt">position=</span><span class="kw">position_nudge</span>(<span class="dt">x=</span><span class="fl">0.3</span>),
    <span class="dt">data =</span> parameters) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> response)) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="dt">guide =</span> <span class="ot">FALSE</span>) +
<span class="st">  </span><span class="kw">scale_size_continuous</span>(<span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="dt">guide =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-24-1.png" width="576"></p>
</div>
<div id="comparing-levels-of-a-factor" class="section level2">
<h2 class="hasAnchor">
<a href="#comparing-levels-of-a-factor" class="anchor"></a>Comparing levels of a factor</h2>
<p>If we wish compare the means from each condition, <code>compare_levels</code> facilitates comparisons of the value of some variable across levels of a factor. By default it computes all pairwise differences:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#N.B. the syntax for compare_levels is experimental and may change</span>
m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/compare_levels.html">compare_levels</a></span>(b, <span class="dt">by =</span> condition) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition, <span class="dt">y =</span> b)) +
<span class="st">  </span><span class="kw">geom_violin</span>(<span class="dt">scale=</span><span class="st">"width"</span>, <span class="dt">fill=</span><span class="st">"gray75"</span>, <span class="dt">color=</span><span class="ot">NA</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="kw">aes</span>(<span class="dt">size=</span>-...prob..), 
    <span class="dt">fun.data=</span>median_qi, <span class="dt">fun.args=</span><span class="kw">list</span>(<span class="dt">.prob=</span><span class="kw">c</span>(.<span class="dv">95</span>,.<span class="dv">66</span>)), <span class="dt">geom=</span><span class="st">"pointrange"</span>, <span class="dt">fatten=</span><span class="fl">1.25</span>)+
<span class="st">  </span><span class="kw">scale_size_continuous</span>(<span class="dt">range=</span><span class="kw">c</span>(<span class="fl">0.5</span>,<span class="fl">1.5</span>), <span class="dt">guide=</span><span class="ot">FALSE</span>) +
<span class="st">  </span><span class="kw">coord_flip</span>()</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-25-1.png" width="672"></p>
</div>
<div id="alternative-estimates-and-intervals-mean-median-mode-qi-hdi" class="section level2">
<h2 class="hasAnchor">
<a href="#alternative-estimates-and-intervals-mean-median-mode-qi-hdi" class="anchor"></a>Alternative estimates and intervals: mean, median, mode; qi, hdi</h2>
<p>The <code>point_interval</code> family of functions follow the naming scheme <code>[mean|median|mode]_[qi|hdi]</code>, and all work in the same way as <code>mean_qi</code>: they take a series of names (or expressions calculated on columns) and summarize those columns with the corresponding point estimate (mean, median, or mode) and interval (qi or hdi). <code>qi</code> yields a quantile interval (a.k.a. equi-tailed interval, central interval, or percentile interval) and <code>hdi</code> yields a highest (posterior) density interval. These can be used in any combination desired. Replacing <code>mean_qi</code> with <code>mode_hdi</code> in the previous example yields mode and HDI instead of mean and quantile interval:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(<span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span>, b[,,condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/point_interval.html">mode_hdi</a></span>(<span class="dt">mu =</span> <span class="st">`</span><span class="dt">(Intercept)</span><span class="st">`</span> +<span class="st"> </span>b) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition, <span class="dt">y =</span> mu, <span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high)) +
<span class="st">  </span><span class="kw">geom_pointrange</span>()</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-26-1.png" width="576"></p>
<p>This is probably more noticeable given a skewed distribution, such as might be expected on a scale parameter:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sd_samples =<span class="st"> </span>m %&gt;%<span class="st"> </span><span class="kw"><a href="../reference/spread_samples.html">spread_samples</a></span>(sigma)

<span class="kw">rbind</span>(
  sd_samples %&gt;%<span class="st"> </span><span class="kw"><a href="../reference/point_interval.html">mode_hdi</a></span>(sigma) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">type=</span><span class="st">"mode_hdi"</span>),
  sd_samples %&gt;%<span class="st"> </span><span class="kw"><a href="../reference/point_interval.html">mean_qi</a></span>(sigma) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">type=</span><span class="st">"mean_qi"</span>)
) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> sigma)) +
<span class="st">  </span><span class="kw">stat_density</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ..scaled.. *<span class="st"> </span><span class="dv">10</span>), <span class="dt">data =</span> sd_samples, <span class="dt">fill=</span><span class="st">"gray75"</span>) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> type)) +
<span class="st">  </span><span class="kw">geom_errorbarh</span>(<span class="kw">aes</span>(<span class="dt">y =</span> type, <span class="dt">xmin =</span> conf.low, <span class="dt">xmax =</span> conf.high), <span class="dt">width=</span><span class="dv">0</span>)</code></pre></div>
<p><img src="tidy-rstanarm_files/figure-html/unnamed-chunk-27-1.png" width="576"></p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#setup">Setup</a></li>
      <li><a href="#example-dataset">Example dataset</a></li>
      <li><a href="#model">Model</a></li>
      <li><a href="#gathering-samples-from-a-fit-in-tidy-format-using-spread_samples">Gathering samples from a fit in tidy-format using <code>spread_samples</code></a></li>
      <li><a href="#point-estimates-and-intervals">Point estimates and intervals</a></li>
      <li><a href="#combining-variables-with-different-indices-in-a-single-tidy-format-data-frame">Combining variables with different indices in a single tidy format data frame</a></li>
      <li><a href="#plotting-point-estimates-and-intervals">Plotting point estimates and intervals</a></li>
      <li><a href="#interval-estimates-with-multiple-probability-levels">Interval estimates with multiple probability levels</a></li>
      <li><a href="#making-posterior-predictions">Making posterior predictions</a></li>
      <li><a href="#comparing-levels-of-a-factor">Comparing levels of a factor</a></li>
      <li><a href="#alternative-estimates-and-intervals-mean-median-mode-qi-hdi">Alternative estimates and intervals: mean, median, mode; qi, hdi</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by <a href="http://www.mjskay.com">Matthew Kay</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
