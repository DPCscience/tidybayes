# gather_lsmeans_samples
#
# Author: mjskay
###############################################################################

# Names that should be suppressed from global variable check by codetools
# Names used broadly should be put in _global_variables.R
# globalVariables(c(".."))


#' Extract samples of lsmeans estimates from a Bayesian model fit into a tidy data format
#'
#' Extract samples from the result of a call to \code{\link{lsmeans}} or \code{\link{ref.grid}} applied to
#' a Bayesian model.
#'
#' \code{\link[lsmeans]{lsmeans}} provides a convenient syntax for generating marginal estimates from a model,
#' and can be applied to various Bayesian models, like \code{\link[rstanarm]{stanreg-objects}} and
#' \code{\link{MCMCglmm}}. Given a \code{\link[lsmeans]{ref.grid}} object as returned by functions like
#' \code{\link[lsmeans]{ref.grid}} or \code{\link[lsmeans]{lsmeans}} applied to a Bayesian model,
#' \code{gather_lsmeans_samples} returns a tidy format data frame of samples from
#' the marginal posterior distributions generated by \code{lsmeans}.
#'
#' @param object A \code{\link{ref.grid}} object such as returned by \code{\link[lsmeans]{ref.grid}} or
#' \code{\link[lsmeans]{lsmeans}}.
#'
#' @return A data frame of tidy samples. The columns of the reference grid are returned as-is, with an
#' additional column called \code{estimate} containing samples from the marginal estimates (the name \code{estimate} is
#' used for compatibility with \code{\link{gather_samples}} and \code{\link[broom]{tidy}}). The resulting data
#' frame is grouped by the columns from the reference grid to make use of summary functions like
#' \code{\link{point_interval}} straightforward.
#'
#' @author Matthew Kay
#' @seealso \code{\link{lsmeans}}
#' @keywords manip
#' @examples
#'
#' ##TODO
#'
#' @importFrom magrittr %>%
#' @importFrom purrr map_dfr
#' @importFrom tibble as_tibble
#' @importFrom rlang syms
#' @export
gather_lsmeans_samples = function(object) {
  grid = as_tibble(object@grid)

  # this matrix will have n_iterations rows and nrow(grid) columns,
  # where mat[, i] is the posterior estimate for grid[i, ]
  mat = object@post.beta %*% t(object@linfct)

  samples = map_dfr(seq_len(nrow(grid)), function(i) {
    post = as.vector(mat[, i])
    if (!is.null(offset <- object@grid[i, ".offset."])) {
      post = post + offset
    }
    cbind(
      grid[i, ],
      .chain = NA,
      .iteration = seq_along(post),
      estimate = post
    )
  })

  samples[, names(samples) %>% setdiff(c(".wgt.", ".offset."))] %>%
    as_tibble() %>%
    group_by(!!!syms(names(.) %>% setdiff(c(".chain", ".iteration", "estimate"))))
}
